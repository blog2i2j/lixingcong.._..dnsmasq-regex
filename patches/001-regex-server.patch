diff --git a/Makefile b/Makefile
index a503c82..f28ab37 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,11 @@ MANDIR        = $(PREFIX)/share/man
 LOCALEDIR     = $(PREFIX)/share/locale
 BUILDDIR      = $(SRC)
 DESTDIR       = 
+ifneq ($(BUILD_DEBUG), 1)
 CFLAGS        = -Wall -W -O2
+else
+CFLAGS        = -Wall -W -g
+endif
 LDFLAGS       = 
 COPTS         = 
 RPM_OPT_FLAGS = 
@@ -71,6 +75,13 @@ nft_cflags =    `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_NFTSET $(PKG_CONFIG
 nft_libs =      `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_NFTSET $(PKG_CONFIG) --libs libnftables`
 version =       -DVERSION='\"`$(top)/bld/get-version $(top)`\"'
 
+have_regex = $(shell if echo $(COPTS) | grep HAVE_REGEX >/dev/null 2>&1; then echo yes; fi)
+ifeq ($(have_regex), yes)
+pcre_libname = $(shell if echo $(COPTS) | grep HAVE_PCRE2 >/dev/null 2>&1; then echo libpcre2-8; else echo libpcre; fi)
+pcre_cflags =  `$(PKG_CONFIG) --cflags $(pcre_libname)`
+pcre_libs =    `$(PKG_CONFIG) --libs $(pcre_libname)`
+endif
+
 sum?=$(shell echo $(CC) -DDNSMASQ_COMPILE_FLAGS="$(CFLAGS)" -DDNSMASQ_COMPILE_OPTS $(COPTS) -E $(top)/$(SRC)/dnsmasq.h | ( md5sum 2>/dev/null || md5 ) | cut -f 1 -d ' ')
 sum!=echo $(CC) -DDNSMASQ_COMPILE_FLAGS="$(CFLAGS)" -DDNSMASQ_COMPILE_OPTS $(COPTS) -E $(top)/$(SRC)/dnsmasq.h | ( md5sum 2>/dev/null || md5 ) | cut -f 1 -d ' '
 copts_conf = .copts_$(sum)
@@ -89,8 +100,8 @@ hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
 all : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(nft_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(nft_libs)" \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(nft_cflags) $(pcre_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(nft_libs) $(pcre_libs)" \
  -f $(top)/Makefile dnsmasq 
 
 mostly_clean :
@@ -112,8 +123,8 @@ all-i18n : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
  i18n=-DLOCALEDIR=\'\"$(LOCALEDIR)\"\' \
- build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(nft_cflags)" \
- build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(nft_libs)"  \
+ build_cflags="$(version) $(dbus_cflags) $(idn2_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(nettle_cflags) $(nft_cflags) $(pcre_cflags)" \
+ build_libs="$(dbus_libs) $(idn2_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(nettle_libs) $(gmp_libs) $(ubus_libs) $(nft_libs) $(pcre_libs)"  \
  -f $(top)/Makefile dnsmasq
 	for f in `cd $(PO); echo *.po`; do \
 		cd $(top) && cd $(BUILDDIR) && $(MAKE) top="$(top)" -f $(top)/Makefile $${f%.po}.mo; \
diff --git a/src/config.h b/src/config.h
index 0994f95..38aaa0b 100644
--- a/src/config.h
+++ b/src/config.h
@@ -203,6 +203,7 @@ RESOLVFILE
 /* #define HAVE_CONNTRACK */
 /* #define HAVE_DNSSEC */
 /* #define HAVE_NFTSET */
+/* #define HAVE_REGEX */
 
 /* Default locations for important system files. */
 
@@ -410,6 +411,10 @@ static char *compile_opts =
 "no-"
 #endif
 "i18n "
+#ifndef HAVE_REGEX
+"no-"
+#endif
+"regex "
 #if defined(HAVE_LIBIDN2)
 "IDN2 "
 #else
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index 254bacd..2229abc 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -168,6 +168,24 @@ extern int capget(cap_user_header_t header, cap_user_data_t data);
 /* daemon is function in the C library.... */
 #define daemon dnsmasq_daemon
 
+#ifdef HAVE_REGEX
+#ifdef HAVE_PCRE2
+/* we only need to support ASCII chartable, thus set it to 8 */
+#define PCRE2_CODE_UNIT_WIDTH 8
+#include <pcre2.h>
+#define PCRE_REGEX       pcre2_code
+#define PCRE_REGEX_EXTRA pcre2_match_data
+#define FREE_PCRE_REGEX       pcre2_code_free
+#define FREE_PCRE_REGEX_EXTRA pcre2_match_data_free
+#else
+#include <pcre.h>
+#define PCRE_REGEX       pcre
+#define PCRE_REGEX_EXTRA pcre_extra
+#define FREE_PCRE_REGEX       free
+#define FREE_PCRE_REGEX_EXTRA pcre_free_study
+#endif
+#endif
+
 #define ADDRSTRLEN INET6_ADDRSTRLEN
 
 /* Async event queue */
@@ -607,6 +625,10 @@ struct randfd_list {
 struct server {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  PCRE_REGEX *regex;
+  PCRE_REGEX_EXTRA *pextra;
+#endif
   struct server *next;
   int serial, arrayposn;
   int last_server;
@@ -628,6 +650,10 @@ struct server {
 struct serv_addr4 {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  PCRE_REGEX *regex;
+  PCRE_REGEX_EXTRA *pextra;
+#endif
   struct server *next;
   struct in_addr addr;
 };
@@ -635,6 +661,10 @@ struct serv_addr4 {
 struct serv_addr6 {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  PCRE_REGEX *regex;
+  PCRE_REGEX_EXTRA *pextra;
+#endif
   struct server *next;
   struct in6_addr addr;
 };
@@ -642,6 +672,10 @@ struct serv_addr6 {
 struct serv_local {
   u16 flags, domain_len;
   char *domain;
+#ifdef HAVE_REGEX
+  PCRE_REGEX *regex;
+  PCRE_REGEX_EXTRA *pextra;
+#endif
   struct server *next;
 };
 
@@ -1199,6 +1233,9 @@ extern struct daemon {
   struct rebind_domain *no_rebind;
   int server_has_wildcard;
   int serverarraysz, serverarrayhwm;
+#ifdef HAVE_REGEX
+  int regexserverarraysz, regexlocaldomainarraysz;
+#endif
   struct ipsets *ipsets, *nftsets;
   u32 allowlist_mask;
   struct allowlist *allowlists;
@@ -1937,6 +1974,12 @@ void dump_packet_icmp(int mask, void *packet, size_t len, union mysockaddr *src,
 #endif
 
 /* domain-match.c */
+#ifdef HAVE_REGEX
+int is_local_regex_answer(const char *domain, int *first, int *last);
+int find_regex_server(const char* domain, int is_local, int *arraypos);
+int match_regex(PCRE_REGEX *regex, PCRE_REGEX_EXTRA *pextra, const char *str, size_t len);
+const char *parse_regex_option(const char *arg, PCRE_REGEX **regex, PCRE_REGEX_EXTRA **pextra);
+#endif
 void build_server_array(void);
 int lookup_domain(char *qdomain, int flags, int *lowout, int *highout);
 int filter_servers(int seed, int flags, int *lowout, int *highout);
diff --git a/src/domain-match.c b/src/domain-match.c
index 935a2d3..97b7061 100644
--- a/src/domain-match.c
+++ b/src/domain-match.c
@@ -27,47 +27,90 @@ void build_server_array(void)
 {
   struct server *serv;
   int count = 0;
+#ifdef HAVE_REGEX
+  int regexserverarrayidx = 0;
+  int regexlocaldomainarrayidx = 0;
+  int regexserverarraysz = 0;
+  int regexlocaldomainarraysz = 0;
+#endif
   
-  for (serv = daemon->servers; serv; serv = serv->next)
+  for (serv = daemon->servers; serv; serv = serv->next){
 #ifdef HAVE_LOOP
     if (!(serv->flags & SERV_LOOP))
+#endif
+    {
+#ifdef HAVE_REGEX
+    if(serv->regex)
+      ++regexserverarraysz;
+    else
 #endif
       {
 	count++;
 	if (serv->flags & SERV_WILDCARD)
 	  daemon->server_has_wildcard = 1;
       }
+    }
+  }
   
-  for (serv = daemon->local_domains; serv; serv = serv->next)
+  for (serv = daemon->local_domains; serv; serv = serv->next){
+#ifdef HAVE_REGEX
+    if(serv->regex)
+      ++regexlocaldomainarraysz;
+    else
+#endif
     {
       count++;
       if (serv->flags & SERV_WILDCARD)
 	daemon->server_has_wildcard = 1;
     }
+  }
   
   daemon->serverarraysz = count;
 
+#ifdef HAVE_REGEX
+  if (count > daemon->serverarrayhwm || (regexserverarraysz + regexlocaldomainarraysz) > (daemon->regexserverarraysz + daemon->regexlocaldomainarraysz))
+#else
   if (count > daemon->serverarrayhwm)
+#endif
     {
       struct server **new;
 
       count += 10; /* A few extra without re-allocating. */
 
+#ifdef HAVE_REGEX
+      if ((new = whine_malloc((count + regexserverarraysz + regexlocaldomainarraysz) * sizeof(struct server *))))
+#else
       if ((new = whine_malloc(count * sizeof(struct server *))))
+#endif
 	{
 	  if (daemon->serverarray)
 	    free(daemon->serverarray);
 	  
 	  daemon->serverarray = new;
 	  daemon->serverarrayhwm = count;
+#ifdef HAVE_REGEX
+    daemon->regexserverarraysz = regexserverarraysz;
+    daemon->regexlocaldomainarraysz = regexlocaldomainarraysz;
+#endif
 	}
     }
 
   count = 0;
+#ifdef HAVE_REGEX
+  regexserverarrayidx = daemon->serverarrayhwm;
+  regexlocaldomainarrayidx = regexserverarrayidx + daemon->regexserverarraysz;
+#endif
   
-  for (serv = daemon->servers; serv; serv = serv->next)
+  for (serv = daemon->servers; serv; serv = serv->next){
 #ifdef HAVE_LOOP
     if (!(serv->flags & SERV_LOOP))
+#endif
+    {
+#ifdef HAVE_REGEX
+    if(serv->regex){
+      daemon->serverarray[regexserverarrayidx++]=serv;
+      continue;
+    }else
 #endif
       {
 	daemon->serverarray[count] = serv;
@@ -75,9 +118,18 @@ void build_server_array(void)
 	serv->last_server = -1;
 	count++;
       }
+    }
+  }
   
-  for (serv = daemon->local_domains; serv; serv = serv->next, count++)
-    daemon->serverarray[count] = serv;
+  for (serv = daemon->local_domains; serv; serv = serv->next){
+#ifdef HAVE_REGEX
+    if(serv->regex){
+      daemon->serverarray[regexlocaldomainarrayidx++]=serv;
+      continue;
+    }else
+#endif
+    daemon->serverarray[count++] = serv;
+  }
   
   qsort(daemon->serverarray, daemon->serverarraysz, sizeof(struct server *), order_qsort);
   
@@ -86,6 +138,20 @@ void build_server_array(void)
   for (count = 0; count < daemon->serverarraysz; count++)
     if (!(daemon->serverarray[count]->flags & SERV_IS_LOCAL))
       daemon->serverarray[count]->arrayposn = count;
+
+#ifdef HAVE_REGEX
+  for (count = daemon->serverarrayhwm; count < daemon->serverarrayhwm + daemon->regexserverarraysz; ++count)
+    daemon->serverarray[count]->arrayposn = count;
+#endif
+
+#if 0 // print the whole array, for debug only
+  for(count=0; count < daemon->serverarrayhwm + daemon->regexserverarraysz + daemon->regexlocaldomainarraysz; ++count){
+    struct server* sv= daemon->serverarray[count];
+    if(sv)
+      printf("i = %d, flag=%u, p=%p, nextP=%p, domain = %s, sfd=%p\n",
+              count,  sv->flags,  sv,      sv->next,    sv->domain,   sv->sfd);
+  }
+#endif
 }
 
 /* we're looking for the server whose domain is the longest exact match
@@ -103,6 +169,11 @@ void build_server_array(void)
 */
 int lookup_domain(char *domain, int flags, int *lowout, int *highout)
 {
+#ifdef HAVE_REGEX
+  int needsearchregex = 1;
+  const char* originaldomain = domain;
+#endif
+  int founddomain = 0;
   int rc, crop_query, nodots;
   ssize_t qlen;
   int try, high, low = 0;
@@ -111,7 +182,7 @@ int lookup_domain(char *domain, int flags, int *lowout, int *highout)
   
   /* may be no configured servers. */
   if (daemon->serverarraysz == 0)
-    return 0;
+    goto search_regex;
 
   /* DS records should come from the parent domain. */
   if (flags & F_DS)
@@ -269,9 +340,42 @@ int lookup_domain(char *domain, int flags, int *lowout, int *highout)
 
   /* qlen == -1 when we failed to match even an empty query, if there are no default servers. */
   if (nlow == nhigh || qlen == -1)
-    return 0;
-  
-  return 1;
+    goto search_regex;
+
+  founddomain = 1;
+
+search_regex:
+#ifdef HAVE_REGEX
+  if (founddomain){
+    if (daemon->serverarray[nlow]->domain_len > 0) // have found a valid upstream
+      needsearchregex = 0;
+  }
+
+  if (needsearchregex){
+    int found_regex = find_regex_server(originaldomain, 0, &low);
+
+    if(!found_regex && find_regex_server(originaldomain, 1, &low)){
+      found_regex=1;
+
+      // special step for parse "server=/:xxx:/#"
+      if(daemon->serverarray[low]->flags & SERV_USE_RESOLV){
+        if(filter_servers(try, F_SERVER, &nlow, &nhigh)){
+          low=nlow;
+        }
+      }
+    }
+
+    if(found_regex){
+      if (lowout)
+        *lowout = low;
+      if (highout)
+        *highout = low + 1;
+
+      founddomain = 1;
+    }
+  }
+#endif
+  return founddomain;
 }
 
 int server_samegroup(struct server *a, struct server *b)
@@ -283,6 +387,14 @@ int filter_servers(int seed, int flags, int *lowout, int *highout)
 {
   int nlow = seed, nhigh = seed;
   int i;
+
+#ifdef HAVE_REGEX
+  if(nlow >= daemon->serverarrayhwm){
+    *lowout = nlow;
+    *highout = nlow+1;
+    return 1;
+  }
+#endif
   
   /* expand nlow and nhigh to cover all the records with the same domain 
      nlow is the first, nhigh - 1 is the last. nlow=nhigh means no servers,
@@ -374,6 +486,125 @@ int filter_servers(int seed, int flags, int *lowout, int *highout)
   return (nlow != nhigh);
 }
 
+#ifdef HAVE_REGEX
+// return flags, or 0 if not found
+// if argument domain is NULL, check the 'first' server is local answer, make sure 'first' is valid
+int is_local_regex_answer(const char *domain, int *first, int *last)
+{
+  int flags = 0;
+  int rc = 0;
+  int arraypos = 0;
+  int found = 1;
+
+  if(domain){
+    found = find_regex_server(domain, 1, &arraypos);
+    if(found){
+      *first = arraypos;
+      *last = *first + 1;
+    }
+  }else
+    arraypos = *first;
+
+  if(found){
+    struct server *r = daemon->serverarray[arraypos];
+
+    flags = r->flags;
+    if (flags & SERV_4ADDR)
+      rc = F_IPV4;
+    else if (flags & SERV_6ADDR)
+      rc = F_IPV6;
+    else if (flags & SERV_ALL_ZEROS)
+      rc = F_IPV4 | F_IPV6;
+  }
+  return rc;
+}
+
+// return 0 if failed to find
+int find_regex_server(const char* domain, int is_local, int *arraypos)
+{
+  int iFirst = daemon->serverarrayhwm;
+  int iLast = daemon->serverarrayhwm + daemon->regexserverarraysz;
+  const size_t domainLength = strlen(domain);
+
+  if (is_local){
+    iFirst = iLast;
+    iLast += daemon->regexlocaldomainarraysz;
+  }
+
+  while(iFirst < iLast){
+    struct server* r = daemon->serverarray[iFirst];
+    if (match_regex(r->regex, r->pextra, domain, domainLength)){
+      *arraypos=iFirst;
+      return 1;
+    }
+    ++iFirst;
+  }
+
+  return 0;
+}
+
+// return 0 if failed to match
+int match_regex(PCRE_REGEX *regex, PCRE_REGEX_EXTRA *pextra, const char *str, size_t len)
+{
+#ifdef HAVE_PCRE2
+  return pcre2_match(regex, /* the compiled pattern */
+      (PCRE2_SPTR) str, /* the subject string */
+      len, /* the length of the subject */
+      0, /* start at offset 0 in the subject */
+      0, /* default options */
+      pextra, /* block for storing the result */
+      NULL /* use default match context */
+      ) >= 0;
+#else
+  int captcount = 0;
+  int ret = 0;
+  if (pcre_fullinfo(regex, pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+  {
+    /* C99 dyn-array, or alloca must be used */
+    int ovect[(captcount + 1) * 3];
+    ret = pcre_exec(regex, pextra, str, len, 0, 0, ovect, (captcount + 1) * 3) > 0;
+  }
+  return ret;
+#endif
+}
+
+const char *parse_regex_option(const char *arg, PCRE_REGEX **regex, PCRE_REGEX_EXTRA **pextra)
+{
+#ifdef HAVE_PCRE2
+  int        errornumber;
+  PCRE2_SIZE erroroffset;
+  static PCRE2_UCHAR errbuffer[512];
+
+  *regex = pcre2_compile((PCRE2_SPTR) arg, /* the pattern */
+    PCRE2_ZERO_TERMINATED, /* indicates pattern is zero-terminated */
+    0, /* default options */
+    &errornumber, /* for error number */
+    &erroroffset, /* for error offset */
+    NULL); /* use default compile context */
+
+  if (NULL == *regex) {
+    pcre2_get_error_message(errornumber, errbuffer, sizeof(errbuffer));
+    return (const char*) errbuffer;
+  }
+
+  *pextra = pcre2_match_data_create_from_pattern(*regex, NULL);
+  if (NULL == *pextra){
+    strcpy((char*)errbuffer, "PCRE2: the memory for the block could not be obtained");
+    return (const char*) errbuffer;
+  }
+#else
+  const char *error;
+  int erroff;
+  *regex = pcre_compile(arg, 0, &error, &erroff, NULL);
+  if(NULL == *regex)
+    return error;
+  *pextra = pcre_study(*regex, 0, &error);
+#endif
+
+  return NULL;
+}
+#endif
+
 int is_local_answer(time_t now, int first, char *name)
 {
   int flags = 0;
@@ -529,6 +760,9 @@ static int order(char *qdomain, size_t qlen, struct server *serv)
 static int order_servers(struct server *s1, struct server *s2)
 {
   int rc;
+#ifdef HAVE_REGEX
+  if(!s1) return -1;
+#endif
 
   /* need full comparison of dotless servers in 
      order_qsort() and filter_servers() */
@@ -615,6 +849,10 @@ void mark_servers(int flag)
 	  {
 	    *up = next;
 	    free(serv->domain);
+#ifdef HAVE_REGEX
+      if(serv->regex) { FREE_PCRE_REGEX(serv->regex); serv->regex = NULL; }
+      if(serv->pextra) { FREE_PCRE_REGEX_EXTRA(serv->pextra); serv->pextra = NULL; }
+#endif
 	    free(serv);
 	  }
 	else 
@@ -635,6 +873,10 @@ void cleanup_servers(void)
          server_gone(serv);
          *up = serv->next;
 	 free(serv->domain);
+#ifdef HAVE_REGEX
+   if(serv->regex) { FREE_PCRE_REGEX(serv->regex); serv->regex = NULL; }
+   if(serv->pextra) { FREE_PCRE_REGEX_EXTRA(serv->pextra); serv->pextra = NULL; }
+#endif
 	 free(serv);
        }
       else 
@@ -652,6 +894,9 @@ int add_update_server(int flags,
 		      const char *domain,
 		      union all_addr *local_addr)
 {
+#ifdef HAVE_REGEX
+  const char* regex = NULL;
+#endif
   struct server *serv = NULL;
   char *alloc_domain;
   
@@ -667,10 +912,32 @@ int add_update_server(int flags,
       if (*domain != 0)
 	flags |= SERV_WILDCARD;
     }
-  
+#ifdef HAVE_REGEX
+  else{
+    size_t domainLen=strlen(domain);
+    char* regex_end=(char*)domain+domainLen-1;
+    if (domainLen > 2 && *domain == ':' && *regex_end == ':'){
+      const char* err = NULL;
+
+      ++domain; // skip leading ':'
+      --domainLen; // skip leading ':'
+
+      *regex_end = '\0'; // skip tailing ':'
+      regex = domain;
+
+      // call whine_malloc() instead of canonicalise()
+      if ((alloc_domain = whine_malloc(domainLen)))
+        memcpy(alloc_domain, domain, domainLen);
+    }
+  }
+#endif
+
   if (*domain == 0)
     alloc_domain = whine_malloc(1);
   else
+#ifdef HAVE_REGEX
+  if(!regex)
+#endif
     alloc_domain = canonicalise((char *)domain, NULL);
 
   if (!alloc_domain)
@@ -772,6 +1039,16 @@ int add_update_server(int flags,
   serv->flags = flags;
   serv->domain = alloc_domain;
   serv->domain_len = strlen(alloc_domain);
+  
+#ifdef HAVE_REGEX
+  if (regex){
+    const char* err = NULL;
+    if ((err = (char *)parse_regex_option(regex, &serv->regex, &serv->pextra))){
+      printf("parse_regex_option: %s\n", err);
+      return 0;
+    }
+  }
+#endif
     
   return 1;
 }
diff --git a/src/forward.c b/src/forward.c
index e2f64c0..be969e3 100644
--- a/src/forward.c
+++ b/src/forward.c
@@ -393,6 +393,11 @@ static void forward_query(int udpfd, union mysockaddr *udpaddr,
 
       if (!extract_name(header, plen, NULL, (char *)&forward->frec_src.encode_bitmap, EXTR_NAME_FLIP, 1))
 	goto reply;
+
+#ifdef HAVE_REGEX
+	if ((flags = is_local_regex_answer(NULL, &first, &last)))
+		goto reply;
+#endif
       
       /* Keep copy of query for retries and move to TCP */
       if (!(forward->stash = blockdata_alloc((char *)header, plen)))
@@ -433,6 +438,9 @@ static void forward_query(int udpfd, union mysockaddr *udpaddr,
 	      forward->forwardall = 1;
 	    }
 	  else
+#ifdef HAVE_REGEX
+		if(!master->regex)
+#endif
 	    start = master->last_server;
 	}
     }
@@ -473,7 +481,14 @@ static void forward_query(int udpfd, union mysockaddr *udpaddr,
 	    forward->sentto->failed_queries++;
 	  else
 	    forward->sentto->retrys++;
-	  
+
+#ifdef HAVE_REGEX
+	  if(forward->sentto->regex){
+	    start = first = forward->sentto->arrayposn;
+	    last = first + 1;
+	    forward->forwardall = 0;
+	  }else
+#endif
 	  if (!filter_servers(forward->sentto->arrayposn, F_SERVER, &first, &last))
 	    goto reply;
 	  
@@ -523,8 +538,13 @@ static void forward_query(int udpfd, union mysockaddr *udpaddr,
   while (1)
     { 
       int fd;
-      struct server *srv = daemon->serverarray[start];
-      
+
+	struct server *srv = daemon->serverarray[start];
+#ifdef HAVE_REGEX
+	if (srv->regex)
+		forward->forwardall = 0; // make it send only once
+#endif
+
       if ((fd = allocate_rfd(&forward->rfds, srv)) != -1)
 	{
 	  
@@ -2574,8 +2594,17 @@ unsigned char *tcp_request(int confd, time_t now,
 	  checking_disabled = header->hb4 & HB4_CD;
 	  
 	  if (lookup_domain(daemon->namebuff, gotname, &first, &last))
+	  {
 	    flags = is_local_answer(now, first, daemon->namebuff);
+#ifdef HAVE_REGEX
+	    if(!flags)
+	      flags = is_local_regex_answer(NULL, &first, &last);
+#endif
+	  }
 	  else
+#ifdef HAVE_REGEX
+	    if(!(flags = is_local_regex_answer(daemon->namebuff, &first, &last)))
+#endif
 	    ede = EDE_NOT_READY;
 	  
 	  if (!flags && ede == EDE_UNSET)
@@ -2590,7 +2619,11 @@ unsigned char *tcp_request(int confd, time_t now,
 		{
 		  master = daemon->serverarray[first];
 		  
+#ifdef HAVE_REGEX
+		  if (option_bool(OPT_ORDER) || master->last_server == -1 || master->regex)
+#else
 		  if (option_bool(OPT_ORDER) || master->last_server == -1)
+#endif
 		    start = first;
 		  else
 		    start = master->last_server;
diff --git a/src/network.c b/src/network.c
index fd602f8..e77a9e1 100644
--- a/src/network.c
+++ b/src/network.c
@@ -1638,6 +1638,10 @@ void check_servers(int no_loop_check)
 	    s1 = _("unqualified"), s2 = _("names");
 	  else if (strlen(serv->domain) == 0)
 	    s1 = _("default"), s2 = "";
+  #ifdef HAVE_REGEX
+    else if (serv->regex)
+      s1 = _("regex domain"), s2 = serv->domain;
+  #endif
 	  else
 	    s1 = _("domain"), s2 = serv->domain, s4 = (serv->flags & SERV_WILDCARD) ? "*" : "";
 	  
@@ -1669,6 +1673,10 @@ void check_servers(int no_loop_check)
 	 }
        else if (serv->flags & SERV_USE_RESOLV && serv->domain_len != 0)
 	 my_syslog(LOG_INFO, _("using standard nameservers for %s"), serv->domain);
+#ifdef HAVE_REGEX
+      else if (serv->regex && serv->domain_len != 0)
+        my_syslog(LOG_INFO, _("using standard nameservers for regex domain %s"), serv->domain);
+#endif
     }
   
   if (locals > LOCALS_LOGGED)
